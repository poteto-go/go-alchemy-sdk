package e2e

import (
	"math/big"
	"os"
	"strconv"
	"testing"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/poteto-go/go-alchemy-sdk/_fixture/artifacts"
	"github.com/poteto-go/go-alchemy-sdk/gas"
	"github.com/poteto-go/go-alchemy-sdk/types"
	"github.com/poteto-go/go-alchemy-sdk/wallet"
	"github.com/stretchr/testify/assert"
)

// These are generated by hardhat
// Not credential
var initPrivateKey = "bcdf20249abf0ed6d944c0288fad489e33f66b3960d9e6229c1cd214ed3bbe31"
var initAddress = "0x8943545177806ED17B9F23F0a21ee5948eCaa776"
var otherAddress = "0xE25583099BA105D9ec0A67f5Ae86D90e50036425"
var deployedContractAddress common.Address
var alchemy gas.Alchemy

func TestMain(m *testing.M) {
	setup()

	m.Run()

	teardown()
}

func setup() {
	port, err := strconv.Atoi(os.Getenv("RPC_PORT"))
	if err != nil {
		panic(err)
	}

	setting := gas.AlchemySetting{
		PrivateNetworkConfig: gas.PrivateNetworkConfig{
			Host: "127.0.0.1",
			Port: port,
		},
	}
	alchemy = gas.NewAlchemy(setting)
}

func teardown() {
}

func TestSenario_BaseMethod(t *testing.T) {
	t.Run("GetGasPrice", func(t *testing.T) {
		gasPrice, err := alchemy.Core.GetGasPrice()

		assert.Nil(t, err)
		assert.Equal(t, gasPrice.Cmp(big.NewInt(0)), 1)
	})

	t.Run("estimate gas", func(t *testing.T) {
		gas, err := alchemy.Core.EstimateGas(types.TransactionRequest{
			From:  initAddress,
			To:    "0x0",
			Value: "0x0",
		})

		assert.Nil(t, err)
		assert.Equal(t, gas.Cmp(big.NewInt(0)), 1)
	})
}

func TestScenario_GetBalance(t *testing.T) {
	t.Run("core namespace case", func(t *testing.T) {
		balance, err := alchemy.Core.GetBalance(initAddress, "latest")

		assert.Nil(t, err)
		assert.Equal(t, balance.Cmp(big.NewInt(0)), 1)
	})

	t.Run("1. can create wallet 2. connect wallet 3. can get balance", func(t *testing.T) {
		w, err := wallet.New(initPrivateKey)

		assert.Nil(t, err)

		w.Connect(alchemy.GetProvider())

		balance, err := w.GetBalance()

		assert.Nil(t, err)
		assert.Equal(t, balance.Cmp(big.NewInt(0)), 1)
	})
}

func TestSenario_DeployContract(t *testing.T) {
	t.Run("1. can create wallet 2. connect wallet 3. can deploy contract", func(t *testing.T) {
		w, err := wallet.New(initPrivateKey)

		assert.Nil(t, err)

		w.Connect(alchemy.GetProvider())

		contractAddress, err := w.DeployContract(&artifacts.PotetoStorageMetaData)

		assert.Nil(t, err)
		assert.NotEqual(t, contractAddress, common.HexToAddress("0x0"))
		deployedContractAddress = contractAddress

		t.Run("IsContractAddress is true", func(t *testing.T) {
			isContractAddress := alchemy.Core.IsContractAddress(deployedContractAddress.Hex())

			assert.True(t, isContractAddress)
		})

		t.Run("can get Code", func(t *testing.T) {
			code, err := alchemy.Core.GetCode(deployedContractAddress.Hex(), types.BlockTagOrHash{
				BlockTag: "latest",
			})

			assert.Nil(t, err)
			assert.Equal(t, code[:8], artifacts.PotetoStorageMetaData.Bin[2:10])

			block, err := alchemy.Core.GetBlock(types.BlockTagOrHash{
				BlockTag: "latest",
			})

			assert.Nil(t, err)

			blockHash := block.Hash()
			code, err = alchemy.Core.GetCode(deployedContractAddress.Hex(), types.BlockTagOrHash{
				BlockHash: blockHash.Hex(),
			})

			assert.Nil(t, err)
			assert.Equal(t, code[:8], artifacts.PotetoStorageMetaData.Bin[2:10])

			t.Run("can get transaction & its receipt form deployed block", func(t *testing.T) {
				txHash := block.Body().Transactions[0].Hash()
				tx, isPending, err := alchemy.Core.GetTransaction(txHash.Hex())

				assert.Nil(t, err)
				assert.False(t, isPending)
				assert.Equal(t, tx.Hash().Hex(), txHash.Hex())

				txReceipt, err := alchemy.Core.GetTransactionReceipt(txHash.Hex())

				assert.Nil(t, err)
				assert.Equal(t, txReceipt.TxHash.Hex(), txHash.Hex())
			})
		})

		t.Run("blockNumber > 0", func(t *testing.T) {
			blockNumber, err := alchemy.Core.GetBlockNumber()

			assert.Nil(t, err)
			assert.Greater(t, blockNumber, uint64(0))
		})
	})
}

func TestScenario_SendTransaction(t *testing.T) {
	w, err := wallet.New(initPrivateKey)

	assert.Nil(t, err)
	w.Connect(alchemy.GetProvider())

	t.Run("can get pending nonce", func(t *testing.T) {
		pendingNonce, err := w.PendingNonceAt()

		assert.Nil(t, err)
		assert.NotEqual(t, pendingNonce, uint64(0)) // first transaction
	})

	t.Run("can send transaciton", func(t *testing.T) {
		balance, err := w.GetBalance()

		assert.Nil(t, err)

		txRequest := types.TransactionRequest{
			From:     initAddress,
			To:       otherAddress,
			Value:    "0x123",
			GasLimit: 300000,
		}

		err = w.SendTransaction(txRequest)

		assert.Nil(t, err)

		ticker := time.NewTicker(1 * time.Second)
		defer ticker.Stop()
		timeout := time.After(30 * time.Second)

		for {
			select {
			case <-ticker.C:
				afterBalance, err := w.GetBalance()
				if err != nil {
					assert.Fail(t, "error")
				}
				if balance.Cmp(afterBalance) == 1 {
					assert.True(t, true)
					return
				}
			case <-timeout:
				assert.Fail(t, "timeout")
				return
			}
		}
	})
}
